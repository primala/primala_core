create type "public"."request_status" as enum ('pending', 'accepted', 'rejected');

create table "public"."collaborator_relationships" (
    "id" bigint generated by default as identity not null,
    "collaborator_one_uid" uuid not null,
    "collaborator_two_uid" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."collaborator_relationships" enable row level security;

create table "public"."collaborator_requests" (
    "id" bigint generated by default as identity not null,
    "sender_uid" uuid not null default auth.uid(),
    "recipient_uid" uuid not null,
    "status" request_status not null default 'pending'::request_status
);


alter table "public"."collaborator_requests" enable row level security;

CREATE UNIQUE INDEX collaborator_relationships_pkey ON public.collaborator_relationships USING btree (id);

CREATE UNIQUE INDEX collaborator_requests_pkey ON public.collaborator_requests USING btree (id);

CREATE UNIQUE INDEX idx_unique_collaborator_relationship ON public.collaborator_relationships USING btree (LEAST(collaborator_one_uid, collaborator_two_uid), GREATEST(collaborator_one_uid, collaborator_two_uid));

alter table "public"."collaborator_relationships" add constraint "collaborator_relationships_pkey" PRIMARY KEY using index "collaborator_relationships_pkey";

alter table "public"."collaborator_requests" add constraint "collaborator_requests_pkey" PRIMARY KEY using index "collaborator_requests_pkey";

alter table "public"."collaborator_relationships" add constraint "collaborator_relationships_collaborator_one_uid_fkey" FOREIGN KEY (collaborator_one_uid) REFERENCES user_information(uid) not valid;

alter table "public"."collaborator_relationships" validate constraint "collaborator_relationships_collaborator_one_uid_fkey";

alter table "public"."collaborator_relationships" add constraint "collaborator_relationships_collaborator_two_uid_fkey" FOREIGN KEY (collaborator_two_uid) REFERENCES user_information(uid) not valid;

alter table "public"."collaborator_relationships" validate constraint "collaborator_relationships_collaborator_two_uid_fkey";

alter table "public"."collaborator_requests" add constraint "collaborator_requests_recipient_uid_fkey" FOREIGN KEY (recipient_uid) REFERENCES user_information(uid) not valid;

alter table "public"."collaborator_requests" validate constraint "collaborator_requests_recipient_uid_fkey";

alter table "public"."collaborator_requests" add constraint "collaborator_requests_sender_uid_fkey" FOREIGN KEY (sender_uid) REFERENCES user_information(uid) not valid;

alter table "public"."collaborator_requests" validate constraint "collaborator_requests_sender_uid_fkey";

grant delete on table "public"."collaborator_relationships" to "anon";

grant insert on table "public"."collaborator_relationships" to "anon";

grant references on table "public"."collaborator_relationships" to "anon";

grant select on table "public"."collaborator_relationships" to "anon";

grant trigger on table "public"."collaborator_relationships" to "anon";

grant truncate on table "public"."collaborator_relationships" to "anon";

grant update on table "public"."collaborator_relationships" to "anon";

grant delete on table "public"."collaborator_relationships" to "authenticated";

grant insert on table "public"."collaborator_relationships" to "authenticated";

grant references on table "public"."collaborator_relationships" to "authenticated";

grant select on table "public"."collaborator_relationships" to "authenticated";

grant trigger on table "public"."collaborator_relationships" to "authenticated";

grant truncate on table "public"."collaborator_relationships" to "authenticated";

grant update on table "public"."collaborator_relationships" to "authenticated";

grant delete on table "public"."collaborator_relationships" to "service_role";

grant insert on table "public"."collaborator_relationships" to "service_role";

grant references on table "public"."collaborator_relationships" to "service_role";

grant select on table "public"."collaborator_relationships" to "service_role";

grant trigger on table "public"."collaborator_relationships" to "service_role";

grant truncate on table "public"."collaborator_relationships" to "service_role";

grant update on table "public"."collaborator_relationships" to "service_role";

grant delete on table "public"."collaborator_requests" to "anon";

grant insert on table "public"."collaborator_requests" to "anon";

grant references on table "public"."collaborator_requests" to "anon";

grant select on table "public"."collaborator_requests" to "anon";

grant trigger on table "public"."collaborator_requests" to "anon";

grant truncate on table "public"."collaborator_requests" to "anon";

grant update on table "public"."collaborator_requests" to "anon";

grant delete on table "public"."collaborator_requests" to "authenticated";

grant insert on table "public"."collaborator_requests" to "authenticated";

grant references on table "public"."collaborator_requests" to "authenticated";

grant select on table "public"."collaborator_requests" to "authenticated";

grant trigger on table "public"."collaborator_requests" to "authenticated";

grant truncate on table "public"."collaborator_requests" to "authenticated";

grant update on table "public"."collaborator_requests" to "authenticated";

grant delete on table "public"."collaborator_requests" to "service_role";

grant insert on table "public"."collaborator_requests" to "service_role";

grant references on table "public"."collaborator_requests" to "service_role";

grant select on table "public"."collaborator_requests" to "service_role";

grant trigger on table "public"."collaborator_requests" to "service_role";

grant truncate on table "public"."collaborator_requests" to "service_role";

grant update on table "public"."collaborator_requests" to "service_role";

create policy "Can Delete Relationship If They Are a Collaborator"
on "public"."collaborator_relationships"
as permissive
for delete
to public
using (((collaborator_one_uid = auth.uid()) OR (collaborator_two_uid = auth.uid())));


create policy "Can Insert Relationship As a Collaborator"
on "public"."collaborator_relationships"
as permissive
for insert
to public
with check (((collaborator_one_uid = auth.uid()) OR (collaborator_two_uid = auth.uid())));


create policy "Can View Relationship"
on "public"."collaborator_relationships"
as permissive
for select
to public
using (((collaborator_one_uid = auth.uid()) OR (collaborator_two_uid = auth.uid())));


create policy "Can Create Requests With Basic Limitations"
on "public"."collaborator_requests"
as permissive
for insert
to authenticated
with check (((sender_uid = auth.uid()) AND (sender_uid <> recipient_uid) AND (status = 'pending'::request_status)));


create policy "Can Delete Requests if They Are a Sender or a Recipient"
on "public"."collaborator_requests"
as permissive
for delete
to authenticated
using (((recipient_uid = auth.uid()) OR (sender_uid = auth.uid())));


create policy "Can Only Update if They Are a Recipient"
on "public"."collaborator_requests"
as permissive
for update
to authenticated
using ((recipient_uid = auth.uid()));


create policy "Can See Requests if They Are a Recipient or a Sender"
on "public"."collaborator_requests"
as permissive
for select
to authenticated
using (((recipient_uid = auth.uid()) OR (sender_uid = auth.uid())));

alter
  publication supabase_realtime add table public.collaborator_requests;


drop policy "Can Read: If Is An Authorized Viewer Or Owner" on "public"."user_information";

alter table "public"."user_information" drop column "authorized_viewers";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.are_collaborators(check_uid uuid, target_uid uuid)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$BEGIN
    RETURN EXISTS (
        SELECT 1 
        FROM collaborator_relationships 
        WHERE (collaborator_one_uid = check_uid AND collaborator_two_uid = target_uid)
           OR (collaborator_one_uid = target_uid AND collaborator_two_uid = check_uid)
    );
END;$function$
;

create policy "Can Read: If Is An Friend Or Owner"
on "public"."user_information"
as permissive
for select
to authenticated
using (((uid = auth.uid()) OR are_collaborators(auth.uid(), uid)));

drop policy "READ: Their Own Row" on "public"."user_metadata";

revoke delete on table "public"."user_metadata" from "anon";

revoke insert on table "public"."user_metadata" from "anon";

revoke references on table "public"."user_metadata" from "anon";

revoke select on table "public"."user_metadata" from "anon";

revoke trigger on table "public"."user_metadata" from "anon";

revoke truncate on table "public"."user_metadata" from "anon";

revoke update on table "public"."user_metadata" from "anon";

revoke delete on table "public"."user_metadata" from "authenticated";

revoke insert on table "public"."user_metadata" from "authenticated";

revoke references on table "public"."user_metadata" from "authenticated";

revoke select on table "public"."user_metadata" from "authenticated";

revoke trigger on table "public"."user_metadata" from "authenticated";

revoke truncate on table "public"."user_metadata" from "authenticated";

revoke update on table "public"."user_metadata" from "authenticated";

revoke delete on table "public"."user_metadata" from "service_role";

revoke insert on table "public"."user_metadata" from "service_role";

revoke references on table "public"."user_metadata" from "service_role";

revoke select on table "public"."user_metadata" from "service_role";

revoke trigger on table "public"."user_metadata" from "service_role";

revoke truncate on table "public"."user_metadata" from "service_role";

revoke update on table "public"."user_metadata" from "service_role";

alter table "public"."user_metadata" drop constraint "user_metadata_pkey";

drop index if exists "public"."user_metadata_pkey";

drop table "public"."user_metadata";

alter table "public"."collaborator_requests" add column "sender_name" text not null;

alter publication supabase_realtime add table public.collaborator_relationships;

alter table "public"."collaborator_relationships" drop constraint "collaborator_relationships_pkey";

alter table "public"."collaborator_requests" drop constraint "collaborator_requests_pkey";

drop index if exists "public"."collaborator_relationships_pkey";

drop index if exists "public"."collaborator_requests_pkey";

alter table "public"."collaborator_relationships" drop column "id";

alter table "public"."collaborator_relationships" add column "uid" uuid not null;

alter table "public"."collaborator_requests" drop column "id";

alter table "public"."collaborator_requests" add column "uid" uuid not null default gen_random_uuid();

CREATE UNIQUE INDEX collaborator_relationships_pkey ON public.collaborator_relationships USING btree (uid);

CREATE UNIQUE INDEX collaborator_requests_pkey ON public.collaborator_requests USING btree (uid);

alter table "public"."collaborator_relationships" add constraint "collaborator_relationships_pkey" PRIMARY KEY using index "collaborator_relationships_pkey";

alter table "public"."collaborator_requests" add constraint "collaborator_requests_pkey" PRIMARY KEY using index "collaborator_requests_pkey";

